# Starter pipeline
# Start with a minimal pipeline that you can customize to build and deploy your code.
# Add steps that build, run tests, deploy, and more:
# https://aka.ms/yaml

trigger:
- main

# run every hour
schedules:
- cron: 0 * * * *
  displayName: Hourly Run 
  always: true
  branches:
    include:
    - main
    
pool:
  name: 'MemoBuild-Pool-WCUS'

variables:
  NUGET_PACKAGES: D:\.nuget\packages
  # SDL
  Codeql.Enabled: false
  runCodesignValidationInjection: false
  skipComponentGovernanceDetection: true
  skipNugetSecurityAnalysis: true
  # perf
  VSO_DEDUP_REDIRECT_TIMEOUT_IN_SEC: 5
  # for msbuildcache
  EnablePipelineCache: true
  VsDevCmd: 'C:\Program Files\Microsoft Visual Studio\2022\Preview\Common7\Tools\VsDevCmd.bat'
  MSBUILDCACHE_PIPELINECACHING_BENCHMARK: 1000
  # diagnostics
  # CaptureDumps: false

strategy:
  matrix:
    # # auditmode_x64-baseline:
    # #   BuildConfiguration: AuditMode
    # #   BuildPlatform: x64
    # #   AdditionalMsBuildArgs: ''
    # release_x64-baseline:
    #   BuildConfiguration: Release
    #   BuildPlatform: x64
    #   AdditionalMsBuildArgs: ''
    # # release_x86-baseline:
    # #   BuildConfiguration: Release
    # #   BuildPlatform: x86
    # #   AdditionalMsBuildArgs: ''
    # release_arm64-baseline:
    #   BuildConfiguration: Release
    #   BuildPlatform: arm64
    #   AdditionalMsBuildArgs: ''
    # auditmode_x64-MSBuildCache:
    #   BuildConfiguration: AuditMode
    #   BuildPlatform: x64
    #   AdditionalMsBuildArgs: '-graph -reportfileaccesses -p:MSBuildCacheLogDirectory=$(Build.ArtifactStagingDirectory)\logs\MSBuildCache'
    release_x64-MSBuildCache:
      BuildConfiguration: Release
      BuildPlatform: x64
      AdditionalMsBuildArgs: '/nodeReuse:false -graph -reportfileaccesses -p:MSBuildCacheLogDirectory=$(Build.ArtifactStagingDirectory)\logs\MSBuildCache'
      MSBuildCacheEnabled: 'true'
    # release_x86-MSBuildCache:
    #   BuildConfiguration: Release
    #   BuildPlatform: x86
    #   AdditionalMsBuildArgs: '-graph -reportfileaccesses -p:MSBuildCacheLogDirectory=$(Build.ArtifactStagingDirectory)\logs\MSBuildCache'
    # release_arm64-MSBuildCache:
    #   BuildConfiguration: Release
    #   BuildPlatform: arm64
    #   AdditionalMsBuildArgs: '/nodeReuse:false -graph -reportfileaccesses -p:MSBuildCacheLogDirectory=$(Build.ArtifactStagingDirectory)\logs\MSBuildCache'
    #   MSBuildCacheEnabled: 'true'

steps:
- powershell: |
    Get-MpPreference
    Set-MpPreference -DisableRealtimeMonitoring $true
    Set-MpPreference -DisableTDTFeature $true

    # Let's see if random internet person is right
    copy C:\Windows\system32\cmd.exe StandardCollector.Service.exe
    .\StandardCollector.Service.exe /C echo Reset please
    Get-MpPreference
  displayName: 'Fix CPU sampling'

- script: |
    @echo on

    set MISTAKEN_PATH=%CD%ReFS.vhdx

    pushd %TEMP%
    rmdir /s /q cow_test
    git clone https://github.com/johnterickson/cow_test.git
    cd cow_test
    set COW_TEST_DIR=%CD%
    dotnet build
    popd
    
    D:
    cd \

    echo SELECT VDISK FILE=D:\ReFS.vhdx > diskpart.script.txt
    echo DETACH VDISK >> diskpart.script.txt
    diskpart /s diskpart.script.txt
    del D:\ReFS.vhdx
    del diskpart.script.txt

    echo SELECT VDISK FILE=%MISTAKEN_PATH% > diskpart.script.txt
    echo DETACH VDISK >> diskpart.script.txt
    diskpart /s diskpart.script.txt
    del %MISTAKEN_PATH%
    del diskpart.script.txt

    echo CREATE VDISK FILE=D:\ReFS.vhdx MAXIMUM=250000 TYPE=EXPANDABLE > diskpart.script.txt
    echo SELECT VDISK FILE=D:\ReFS.vhdx >> diskpart.script.txt
    echo ATTACH VDISK >> diskpart.script.txt
    echo CREATE PARTITION PRIMARY >> diskpart.script.txt
    echo FORMAT FS=REFS QUICK >> diskpart.script.txt
    echo ASSIGN LETTER=R >> diskpart.script.txt
    type diskpart.script.txt
    diskpart /s diskpart.script.txt
    del diskpart.script.txt

    format R: /fs:ReFS /Q /X /Y /DevDrv || format R: /fs:ReFS /Q /X /Y

    pushd %COW_TEST_DIR%
    echo test > r:\test.txt
    dotnet run -- "r:\test.txt" "r:\test.txt.cloned"
    del r:\test.txt
    del r:\test.txt.cloned
    popd

    IF EXIST "%AGENT_BUILDDIRECTORY%.old" ( rmdir /s /q "%AGENT_BUILDDIRECTORY%.old" )
    IF EXIST "%AGENT_BUILDDIRECTORY%" (
      rmdir /s /q "%AGENT_BUILDDIRECTORY%" || move "%AGENT_BUILDDIRECTORY%" "%AGENT_BUILDDIRECTORY%.old"
    )

    mkdir "%AGENT_BUILDDIRECTORY%"
    echo SELECT VDISK FILE=D:\ReFS.vhdx >> diskpart.script.txt
    echo SELECT VOLUME=R >> diskpart.script.txt
    echo ASSIGN MOUNT=%AGENT_BUILDDIRECTORY% >> diskpart.script.txt
    type diskpart.script.txt
    diskpart /s diskpart.script.txt
    del diskpart.script.txt

    mkdir "$(Build.ArtifactStagingDirectory)"
    mkdir "$(Build.BinariesDirectory)"
    mkdir "$(Build.SourcesDirectory)"
    mkdir "$(Common.TestResultsDirectory)"
    
    IF EXIST "\MSBuildCache.old" ( rmdir /s /q "\MSBuildCache.old" )
    IF EXIST "\MSBuildCache" (
      rmdir /s /q "\MSBuildCache" || move "\MSBuildCache" "\MSBuildCache.old"
    )

    SET MSBuildCacheLocalCacheRootPath=R:\MSBuildCache
    echo ##vso[task.setvariable variable=MSBuildCacheLocalCacheRootPath;]R:\MSBuildCache

    # pushd %COW_TEST_DIR%
    # mkdir %MSBuildCacheLocalCacheRootPath%
    # echo test > %MSBuildCacheLocalCacheRootPath%\test.txt
    # dotnet run -- "%MSBuildCacheLocalCacheRootPath%\test.txt" "%MSBuildCacheLocalCacheRootPath%\test.txt.cloned"
    # dotnet run -- "%MSBuildCacheLocalCacheRootPath%\test.txt" "%AGENT_BUILDDIRECTORY%\test.txt.cloned"
    # del %MSBuildCacheLocalCacheRootPath%\test.txt
    # del %MSBuildCacheLocalCacheRootPath%\test.txt.cloned
    # del %AGENT_BUILDDIRECTORY%\test.txt.cloned
    # popd

    mkdir R:\TEMP
    echo ##vso[task.setvariable variable=TEMP;]R:\TEMP

    cd /d "$(Build.SourcesDirectory)"
    echo test > test.txt
    dotnet run --project %COW_TEST_DIR%\cow_test.csproj -- "%CD%\test.txt" "%CD%\test.txt.cloned"
    set TEST_RESULT=%ERRORLEVEL%
    del test.txt
    del test.txt.cloned

    exit /b %TEST_RESULT%
  displayName: 'Remap AGENT_BUILDDIRECTORY to a ReFS (DevDrv if available) volume'

- checkout: self
  submodules: recursive

# set up env (vs preview)
- script: |
    cd %TEMP%
    echo delete old logs
    del dd_*
    del vs_enterprise.exe
    
    curl.exe -L https://aka.ms/vs/17/pre/vs_enterprise.exe -o vs_enterprise.exe
    
    vs_enterprise.exe --passive --norestart --wait --config %CD%\.vsconfig
    set VS_ERRORLEVEL=%ERRORLEVEL%
    del vs_enterprise.exe

    echo store logs
    mkdir "$(Build.ArtifactStagingDirectory)\logs"
    mkdir "$(Build.ArtifactStagingDirectory)\logs\VSSetup"
    move dd_* "$(Build.ArtifactStagingDirectory)\logs\VSSetup\"
    
    IF "%VS_ERRORLEVEL%"=="0" (
      echo install success: %VS_ERRORLEVEL%
      exit /b 0
    )
    IF "%VS_ERRORLEVEL%"=="3010" (
      echo install success: %VS_ERRORLEVEL%
      exit /b 0
    )

    echo install fail: %VS_ERRORLEVEL%

    CALL "$(VsDevCmd)"
    msbuild --version
  displayName: 'Install VS Preview'

- script: |
    rmdir /s /q "$(Build.ArtifactStagingDirectory)\logs"
    mkdir "$(Build.ArtifactStagingDirectory)\logs"
    rmdir /s /q "\MSBuildCache"
    rmdir /s /q "R:\MSBuildCache"
    git clean -xdf || git clean -xdf
  displayName: 'Clean up'

- template: .\build\pipelines\templates-v2\steps-restore-nuget.yml

- script: |
    del /q %TEMP%\procdump.exe
    curl.exe https://live.sysinternals.com/procdump.exe -o %TEMP%\procdump.exe
    mkdir "$(Build.ArtifactStagingDirectory)\logs" 2>NUL
    start cmd /c %TEMP%\procdump.exe -w -ma -n 10 -s 60 msbuild "$(Build.ArtifactStagingDirectory)\logs" ^> $(Build.ArtifactStagingDirectory)\logs\procdump.log 2^>^&1
    exit /b 0
  condition: and(succeeded(), eq(variables['CaptureDumps'], 'true'))
  displayName: 'Start procdump'

- task: DiagnosticsTask@0
  displayName: 'Start PerfView'
  inputs:
    operation: start
    collectors: |
      - perfview: -ClrEvents=JITSymbols -KernelEvents=Process+Thread+ImageLoad+Profile -CPUSampleMSec:1000

- script: >
    echo ON &&
    CALL "$(VsDevCmd)" &&
    cd /d "$(Build.SourcesDirectory)" &&
    msbuild.exe /m OpenConsole.sln
    /p:Platform=$(BuildPlatform)
    /p:Configuration=$(BuildConfiguration)
    /p:WindowsTerminalOfficialBuild=true;WindowsTerminalBranding=Dev;PGOBuildMode=None
    /bl:$(Build.ArtifactStagingDirectory)\logs\msbuild.binlog
    /ds:false
    $(AdditionalMsBuildArgs)
  displayName: 'Build OpenConsole.sln'
  env:
    SYSTEM_ACCESSTOKEN: $(System.AccessToken)

# - task: VSBuild@1
#   displayName: Build OpenConsole.sln
#   inputs:
#     solution: 'OpenConsole.sln'
#     msbuildArgs: >-
#       /p:WindowsTerminalOfficialBuild=true;WindowsTerminalBranding=Dev;PGOBuildMode=None
#       /bl:$(Build.ArtifactStagingDirectory)\logs\msbuild.binlog
#       /ds:false
#       $(AdditionalMsBuildArgs)
#     platform: $(BuildPlatform)
#     configuration: $(BuildConfiguration)
#     msbuildArchitecture: x64
#     maximumCpuCount: true
#   env:
#     SYSTEM_ACCESSTOKEN: $(System.AccessToken)

- script: |
    taskkill /f /im msbuild.exe 2>NUL
    echo msbuild stopped
    exit /b 0
  condition: and(succeeded(), eq(variables['CaptureDumps'], 'true'))
  displayName: 'Stop msbuild'
- powershell: |
    Get-Process -Name procdump | Wait-Process -Timeout 30
    Get-Process -Name procdump | Stop-Process
    echo procdump no longer running
  displayName: 'Wait for procdump to finish'
  errorActionPreference: continue
  condition: and(succeeded(), eq(variables['CaptureDumps'], 'true'))

- publish: $(Build.ArtifactStagingDirectory)\logs
  displayName: Publish Logs
  artifact: '$(System.JobDisplayName) logs'
  condition: always()


- script: |
    rmdir /s /q "$(Build.ArtifactStagingDirectory)\logs"
    mkdir "$(Build.ArtifactStagingDirectory)\logs"
    git clean -xdf || git clean -xdf
  displayName: 'Clean up, but keep local cache'

# - script: |
#     pktmon filter remove
#     pktmon filter add AFD -i 13.107.42.20
#     mkdir "$(Build.ArtifactStagingDirectory)\logs"
#     pktmon start --capture --file-name "$(Build.ArtifactStagingDirectory)\logs\pktmon.etl" --log-mode multi-file

- template: .\build\pipelines\templates-v2\steps-restore-nuget.yml
- script: |
    del /q %TEMP%\procdump.exe
    curl.exe https://live.sysinternals.com/procdump.exe -o %TEMP%\procdump.exe
    mkdir "$(Build.ArtifactStagingDirectory)\logs" 2>NUL
    start cmd /c %TEMP%\procdump.exe -w -ma -n 10 -s 30 msbuild "$(Build.ArtifactStagingDirectory)\logs" ^> $(Build.ArtifactStagingDirectory)\logs\procdump.log 2^>^&1
    exit /b 0
  condition: and(succeeded(), eq(variables['CaptureDumps'], 'true'))

- script: >
    echo ON &&
    CALL "$(VsDevCmd)" &&
    cd /d "$(Build.SourcesDirectory)" &&
    msbuild.exe OpenConsole.sln
    /p:Platform=$(BuildPlatform)
    /p:Configuration=$(BuildConfiguration)
    /p:WindowsTerminalOfficialBuild=true;WindowsTerminalBranding=Dev;PGOBuildMode=None
    /bl:$(Build.ArtifactStagingDirectory)\logs\msbuild.binlog
    /ds:false
    $(AdditionalMsBuildArgs)
  displayName: 'Build OpenConsole.sln'
  env:
    SYSTEM_ACCESSTOKEN: $(System.AccessToken)
# - task: VSBuild@1
#   displayName: Build OpenConsole.sln
#   inputs:
#     solution: 'OpenConsole.sln'
#     msbuildArgs: >-
#       /p:WindowsTerminalOfficialBuild=true;WindowsTerminalBranding=Dev;PGOBuildMode=None
#       /bl:$(Build.ArtifactStagingDirectory)\logs\msbuild.binlog
#       /ds:false
#       $(AdditionalMsBuildArgs)
#     platform: $(BuildPlatform)
#     configuration: $(BuildConfiguration)
#     msbuildArchitecture: x64
#     maximumCpuCount: false
#   env:
#     SYSTEM_ACCESSTOKEN: $(System.AccessToken)

# - script: |
#     pktmon counters
#     pktmon stop

- script: |
    taskkill /f /im msbuild.exe 2>NUL
    echo msbuild stopped
    exit /b 0
  condition: and(succeeded(), eq(variables['CaptureDumps'], 'true'))
- powershell: |
    Get-Process -Name procdump | Wait-Process -Timeout 60
    Get-Process -Name procdump | Stop-Process
    echo procdump no longer running
  displayName: 'Wait for procdump to finish'
  errorActionPreference: continue
  condition: and(succeeded(), eq(variables['CaptureDumps'], 'true'))
  
- publish: $(Build.ArtifactStagingDirectory)\logs
  displayName: Publish Logs
  artifact: '$(System.JobDisplayName) logs 2'
  condition: always()